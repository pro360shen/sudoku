<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>ç¨‹åºå…­åä¸‰ï¼šæ¨™æº–è¾¨è­˜èˆ‡è‡ªå‹•è§£ç­”ç‰ˆ</title>
    <script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady()"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <style>
        :root { --p: #00D4FF; --ans: #00FF41; --bg: #121212; }
        body { background: var(--bg); color: #fff; font-family: monospace; margin: 0; padding: 10px; }
        .main-layout { display: flex; flex-direction: row; gap: 15px; justify-content: center; }
        #log { flex: 0 0 320px; background: #000; color: #fff; height: 92vh; padding: 10px; border: 1px solid #333; overflow-y: auto; font-size: 11px; }
        #grid { display: grid; grid-template-columns: repeat(9, 1fr); width: 450px; background: #fff; border: 4px solid #fff; }
        .cell { aspect-ratio: 1; display: flex; align-items: center; justify-content: center; background: #222; font-size: 26px; border: 1px solid #444; color: var(--p); font-weight: bold; }
        .cell.solved { color: var(--ans); } /* è§£ç­”æ•¸å­—é¡¯ç¤ºç¶ è‰² */
        .controls { display: flex; flex-direction: column; gap: 5px; }
        button { width: 100%; padding: 15px; background: var(--p); color: #000; font-weight: bold; cursor: pointer; border: none; }
        button:disabled { background: #444; color: #888; }
        #v { width: 400px; height: 300px; background: #000; }
        canvas { display: block; border: 1px solid #555; margin-top: 5px; }
    </style>
</head>
<body>
<div class="main-layout">
    <div id="log">æ—¥èªŒï¼šæ¨™æº–ç¯„æœ¬è¼‰å…¥ä¸­...</div>
    <div class="center-side">
        <div id="grid"></div>
        <div class="controls">
            <button id="run" disabled>ğŸ“¸ åŸ·è¡Œæ¨™æº–è¾¨è­˜</button>
            <button id="solve" disabled>ğŸ§© ä¸€éµè‡ªå‹•è§£ç­”</button>
        </div>
    </div>
    <div class="camera-panel">
        <video id="v" autoplay playsinline muted></video>
        <canvas id="c_warp" style="width:400px;"></canvas>
    </div>
</div>

<script>
    let cvReady = false, videoReady = false;
    const v = document.getElementById('v'), btnRun = document.getElementById('run'), btnSolve = document.getElementById('solve'), log = document.getElementById('log'), grid = document.getElementById('grid'), cWarp = document.getElementById('c_warp');

    // 1. æ¨™æº–é¡é ­èˆ‡ç’°å¢ƒå•Ÿå‹•
    navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } }).then(s => {
        v.srcObject = s; v.onloadedmetadata = () => { v.play(); videoReady = true; checkInit(); };
    });
    function onOpenCvReady() { cvReady = true; checkInit(); }
    function checkInit() { if(cvReady && videoReady) { btnRun.disabled = false; addLog("ç’°å¢ƒå°±ç·’"); } }

    function addLog(m) {
        const d = document.createElement('div'); d.innerText = `> ${m}`;
        log.appendChild(d); log.scrollTop = log.scrollHeight;
    }

    for(let i=0; i<81; i++) {
        const d = document.createElement('div'); d.className = 'cell'; d.id = 'cell'+i; grid.appendChild(d);
    }

    // 2. æ¨™æº–ç¯„æœ¬è¾¨è­˜é‚è¼¯ (ç¨‹åºå…­åäºŒå…§å®¹)
    btnRun.onclick = async () => {
        btnRun.disabled = true; btnSolve.disabled = true;
        for(let i=0; i<81; i++) { grid.children[i].innerText = ""; grid.children[i].classList.remove('solved'); }
        
        const worker = await Tesseract.createWorker('eng');
        await worker.setParameters({ tessedit_char_whitelist: '123456789', tessedit_pageseg_mode: '10' });

        try {
            const tmpC = document.createElement('canvas'); tmpC.width = v.videoWidth; tmpC.height = v.videoHeight;
            tmpC.getContext('2d').drawImage(v, 0, 0);
            let src = cv.imread(tmpC);
            let gray = new cv.Mat(), thresh = new cv.Mat();
            cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
            cv.adaptiveThreshold(gray, thresh, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 2);
            let contours = new cv.MatVector(), hierarchy = new cv.Mat();
            cv.findContours(thresh, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
            let best = null, maxA = 0;
            for(let i=0; i<contours.size(); i++) {
                let area = cv.contourArea(contours.get(i));
                if(area > 8000) {
                    let approx = new cv.Mat();
                    cv.approxPolyDP(contours.get(i), approx, 0.03 * cv.arcLength(contours.get(i), true), true);
                    if(approx.rows === 4 && area > maxA) { maxA = area; best = approx; }
                }
            }
            if(!best) throw new Error("å®šä½å¤±æ•—");

            let pts = []; for(let i=0; i<4; i++) pts.push({x:best.data32S[i*2], y:best.data32S[i*2+1]});
            let sum = pts.map(p => p.x+p.y), diff = pts.map(p => p.x-p.y);
            let sorted = [pts[sum.indexOf(Math.min(...sum))], pts[diff.indexOf(Math.max(...diff))], pts[sum.indexOf(Math.max(...sum))], pts[diff.indexOf(Math.min(...diff))]];
            const w = Math.hypot(sorted[1].x - sorted[0].x, sorted[1].y - sorted[0].y);
            const h = Math.hypot(sorted[3].x - sorted[0].x, sorted[3].y - sorted[0].y);
            let M = cv.getPerspectiveTransform(cv.matFromArray(4, 1, cv.CV_32FC2, [sorted[0].x, sorted[0].y, sorted[1].x, sorted[1].y, sorted[2].x, sorted[2].y, sorted[3].x, sorted[3].y]), cv.matFromArray(4, 1, cv.CV_32FC2, [0,0, w,0, w,h, 0,h]));
            let warped = new cv.Mat(); cv.warpPerspective(gray, warped, M, new cv.Size(w, h));
            let ocrMat = new cv.Mat();
            cv.threshold(warped, ocrMat, 0, 255, cv.THRESH_BINARY | cv.THRESH_OTSU);
            cv.imshow(cWarp, ocrMat); 

            const sW = w / 9, sH = h / 9;
            for(let i=0; i<81; i++) {
                const r = Math.floor(i / 9), c = i % 9;
                let cell = ocrMat.roi(new cv.Rect(c*sW+2, r*sH+2, sW-4, sH-4));
                const sample = document.createElement('canvas'); sample.width = 40; sample.height = 40;
                cv.imshow(sample, cell);
                const res = await worker.recognize(sample);
                const val = res.data.text.trim();
                if(/^[1-9]$/.test(val)) {
                    document.getElementById('cell' + i).innerText = val;
                }
                cell.delete();
            }
            addLog("è¾¨è­˜å®Œæˆï¼Œå¯åŸ·è¡Œè§£ç­”");
            btnSolve.disabled = false;
            await worker.terminate();
        } catch(e) { addLog(e.message); }
        finally { btnRun.disabled = false; }
    };

    // 3. æ¨™æº–æ•¸ç¨è§£ç­”é‚è¼¯ (ä¸ä¿®æ”¹è¾¨è­˜çµæœ)
    btnSolve.onclick = () => {
        let board = [];
        for(let i=0; i<81; i++) {
            let val = document.getElementById('cell'+i).innerText;
            board.push(val === "" ? 0 : parseInt(val));
        }

        if(solveSudoku(board)) {
            for(let i=0; i<81; i++) {
                let cell = document.getElementById('cell'+i);
                if(cell.innerText === "") {
                    cell.innerText = board[i];
                    cell.classList.add('solved');
                }
            }
            addLog("è§£ç­”æˆåŠŸï¼");
        } else {
            addLog("æ­¤é¡Œç„¡è§£ï¼Œè«‹æ ¸å°è¾¨è­˜çµæœ");
        }
    };

    function solveSudoku(b) {
        let empty = b.indexOf(0);
        if(empty === -1) return true;
        let r = Math.floor(empty/9), c = empty%9;
        for(let v=1; v<=9; v++) {
            if(isValid(b, r, c, v)) {
                b[empty] = v;
                if(solveSudoku(b)) return true;
                b[empty] = 0;
            }
        }
        return false;
    }

    function isValid(b, r, c, v) {
        for(let i=0; i<9; i++) if(b[r*9+i] === v || b[i*9+c] === v) return false;
        let rr = Math.floor(r/3)*3, cc = Math.floor(c/3)*3;
        for(let i=0; i<3; i++) for(let j=0; j<3; j++) if(b[(rr+i)*9+(cc+j)] === v) return false;
        return true;
    }
</script>
</body>
</html>