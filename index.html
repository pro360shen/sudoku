<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>ç¨‹åºä¸ƒåä¸€ï¼šåº§æ¨™çµ•å°é–å®šç‰ˆ</title>
    <script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady()"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <style>
        :root { --p: #00D4FF; --ans: #00FF41; --bg: #121212; --org: #FF8C00; }
        body { background: var(--bg); color: #fff; font-family: monospace; margin: 0; padding: 10px; }
        .main-layout { display: flex; flex-direction: row; gap: 15px; justify-content: center; }
        #log { flex: 0 0 300px; background: #000; height: 92vh; padding: 10px; border: 1px solid #333; overflow-y: auto; font-size: 11px; }
        
        /* æ ¸å¿ƒä¿®æ­£ï¼šåº§æ¨™çµ•å°é–å®šå®¹å™¨ */
        #grid-container {
            width: 450px;
            height: 450px;
            position: relative;
            background: var(--org); /* åº•åœ–ç•«ç·š */
            padding: 5px; /* å½¢æˆæœ€å¤–åœˆæ©˜ç·š */
            box-sizing: border-box;
        }

        #grid { 
            display: grid; 
            grid-template-columns: repeat(3, 1fr); 
            grid-template-rows: repeat(3, 1fr);
            width: 100%;
            height: 100%;
            gap: 5px; /* é€™å°±æ˜¯ä¹å¤§æ–¹æ¡†çš„æ©˜è‰²ç²—ç·š */
        }

        .sub-grid { 
            display: grid; 
            grid-template-columns: repeat(3, 1fr); 
            gap: 1px; /* å°æ ¼å­ç´°ç¸« */
            background: #444; 
        }

        .cell { 
            background: #222;
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-size: 26px; 
            color: var(--p); 
            font-weight: bold;
            width: 100%;
            height: 100%;
            overflow: hidden; /* é˜²æ­¢æ–‡å­—æ’å¤§å®¹å™¨å°è‡´è®Šèª¿ */
        }

        .cell.solved { color: var(--ans); }
        button { width: 100%; padding: 15px; margin-top: 10px; background: var(--p); color: #000; font-weight: bold; cursor: pointer; border: none; }
        #v { width: 400px; height: 300px; background: #000; }
        canvas { display: block; border: 1px solid #555; margin-top: 5px; }
    </style>
</head>
<body>
<div class="main-layout">
    <div id="log">æ—¥èªŒï¼šæ­£åœ¨åŸ·è¡Œé›¶è®Šèª¿åº§æ¨™é–å®š...</div>
    <div class="center-side">
        <div id="grid-container">
            <div id="grid"></div>
        </div>
        <button id="run" disabled>ğŸ“¸ åŸ·è¡Œæ¨™æº–è¾¨è­˜</button>
        <button id="solve">ğŸ§© ä¸€éµè§£ç­”</button>
    </div>
    <div class="camera-panel">
        <video id="v" autoplay playsinline muted></video>
        <canvas id="c_warp" style="width:400px;"></canvas>
    </div>
</div>

<script>
    // é‚è¼¯æ²¿ç”¨ç¨‹åºå…­åäºŒï¼ˆç‰©ç†æ¯”ä¾‹è¾¨è­˜ç¯„æœ¬ï¼‰
    let cvReady = false, videoReady = false;
    const v = document.getElementById('v'), btnRun = document.getElementById('run'), log = document.getElementById('log'), grid = document.getElementById('grid'), cWarp = document.getElementById('c_warp');

    // å»ºç«‹ç©©å®šçš„å¯¦é«”çµæ§‹æ˜ å°„
    const cellMap = {};
    for(let b=0; b<9; b++) {
        const sub = document.createElement('div');
        sub.className = 'sub-grid';
        for(let c=0; c<9; c++) {
            const d = document.createElement('div');
            d.className = 'cell';
            const row = Math.floor(b/3)*3 + Math.floor(c/3);
            const col = (b%3)*3 + (c%3);
            const id = row * 9 + col;
            d.id = 'cell' + id;
            sub.appendChild(d);
            cellMap[id] = d;
        }
        grid.appendChild(sub);
    }

    navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } }).then(s => {
        v.srcObject = s; v.onloadedmetadata = () => { v.play(); videoReady = true; checkInit(); };
    });
    function onOpenCvReady() { cvReady = true; checkInit(); }
    function checkInit() { if(cvReady && videoReady) btnRun.disabled = false; }

    btnRun.onclick = async () => {
        btnRun.disabled = true;
        for(let i=0; i<81; i++) { cellMap[i].innerText = ""; cellMap[i].classList.remove('solved'); }
        const worker = await Tesseract.createWorker('eng');
        await worker.setParameters({ tessedit_char_whitelist: '123456789', tessedit_pageseg_mode: '10' });
        try {
            const tmpC = document.createElement('canvas'); tmpC.width = v.videoWidth; tmpC.height = v.videoHeight;
            tmpC.getContext('2d').drawImage(v, 0, 0);
            let src = cv.imread(tmpC);
            let gray = new cv.Mat(), thresh = new cv.Mat();
            cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
            cv.adaptiveThreshold(gray, thresh, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 2);
            let contours = new cv.MatVector();
            cv.findContours(thresh, contours, new cv.Mat(), cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
            let best = null, maxA = 0;
            for(let i=0; i<contours.size(); i++) {
                let area = cv.contourArea(contours.get(i));
                if(area > 8000) {
                    let approx = new cv.Mat();
                    cv.approxPolyDP(contours.get(i), approx, 0.03 * cv.arcLength(contours.get(i), true), true);
                    if(approx.rows === 4 && area > maxA) { maxA = area; best = approx; }
                }
            }
            if(!best) throw new Error("å®šä½å¤±æ•—");
            let pts = []; for(let i=0; i<4; i++) pts.push({x:best.data32S[i*2], y:best.data32S[i*2+1]});
            let sum = pts.map(p => p.x+p.y), diff = pts.map(p => p.x-p.y);
            let sorted = [pts[sum.indexOf(Math.min(...sum))], pts[diff.indexOf(Math.max(...diff))], pts[sum.indexOf(Math.max(...sum))], pts[diff.indexOf(Math.min(...diff))]];
            const w = Math.hypot(sorted[1].x - sorted[0].x, sorted[1].y - sorted[0].y);
            const h = Math.hypot(sorted[3].x - sorted[0].x, sorted[3].y - sorted[0].y);
            let M = cv.getPerspectiveTransform(cv.matFromArray(4, 1, cv.CV_32FC2, [sorted[0].x, sorted[0].y, sorted[1].x, sorted[1].y, sorted[2].x, sorted[2].y, sorted[3].x, sorted[3].y]), cv.matFromArray(4, 1, cv.CV_32FC2, [0,0, w,0, w,h, 0,h]));
            let warped = new cv.Mat(); cv.warpPerspective(gray, warped, M, new cv.Size(w, h));
            let ocrMat = new cv.Mat();
            cv.threshold(warped, ocrMat, 0, 255, cv.THRESH_BINARY | cv.THRESH_OTSU);
            cv.imshow(cWarp, ocrMat); 
            const sW = w / 9, sH = h / 9;
            for(let i=0; i<81; i++) {
                const r = Math.floor(i / 9), c = i % 9;
                let cellData = ocrMat.roi(new cv.Rect(c*sW+2, r*sH+2, sW-4, sH-4));
                const canvas = document.createElement('canvas'); canvas.width = 40; canvas.height = 40;
                cv.imshow(canvas, cellData);
                const res = await worker.recognize(canvas);
                if(/^[1-9]$/.test(res.data.text.trim())) cellMap[i].innerText = res.data.text.trim();
                cellData.delete();
            }
            await worker.terminate();
        } catch(e) { console.error(e); }
        finally { btnRun.disabled = false; }
    };

    document.getElementById('solve').onclick = () => {
        let b = [];
        for(let i=0; i<81; i++) b.push(cellMap[i].innerText === "" ? 0 : parseInt(cellMap[i].innerText));
        if(solve(b)) {
            for(let i=0; i<81; i++) {
                if(cellMap[i].innerText === "") {
                    cellMap[i].innerText = b[i];
                    cellMap[i].classList.add('solved');
                }
            }
        }
    };
    function solve(b) {
        let e = b.indexOf(0); if(e===-1) return true;
        let r=Math.floor(e/9), c=e%9;
        for(let v=1; v<=9; v++) {
            if(isValid(b,r,c,v)) { b[e]=v; if(solve(b)) return true; b[e]=0; }
        }
        return false;
    }
    function isValid(b,r,c,v) {
        for(let i=0; i<9; i++) if(b[r*9+i]===v || b[i*9+c]===v) return false;
        let rr=Math.floor(r/3)*3, cc=Math.floor(c/3)*3;
        for(let i=0; i<3; i++) for(let j=0; j<3; j++) if(b[(rr+i)*9+(cc+j)]===v) return false;
        return true;
    }
</script>
</body>
</html>